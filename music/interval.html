<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>0x00A0ÁöÑÈü≥Á®ãÁªÉ‰π†</title>
  <style>
    :root {
      --bg: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: #e5e7eb;
      --ok: #16a34a;
      --bad: #dc2626;
      --blue: #2563eb;
      --panel: #ffffff;
      --staff: rgba(17,24,39,0.55);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;
      color: var(--text);
      background: var(--bg);
    }

    .wrap {
      max-width: 860px;
      margin: 0 auto;
      padding: 18px 14px 40px;
    }

    header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 900;
      letter-spacing: 0.2px;
    }

    .sub {
      margin: 6px 0 0;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }

    .stats {
      display: flex;
      gap: 10px;
      align-items: center;
      color: var(--muted);
      font-size: 12px;
      font-weight: 750;
      flex-wrap: wrap;
    }

    .dot {
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #d1d5db;
      display: inline-block;
      transform: translateY(-1px);
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      padding: 14px;
    }

    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .noteNames {
      font-size: 18px;
      font-weight: 900;
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
    }

    .staffWrap {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fafafa;
      padding: 10px;
    }

    svg { display: block; width: 100%; height: auto; }

    .choices {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin-top: 12px;
    }

    @media (max-width: 680px) {
      .choices { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }

    button {
      border: 1px solid var(--border);
      background: #ffffff;
      border-radius: 10px;
      padding: 10px 10px;
      cursor: pointer;
      color: var(--text);
      font-weight: 800;
      transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
      text-align: left;
    }

    button:hover {
      border-color: rgba(37,99,235,0.55);
      transform: translateY(-1px);
    }

    button:active { transform: translateY(0px); }
    button[disabled] { opacity: 0.55; cursor: not-allowed; }

    .feedback {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      background: #fff;
    }

    .msg {
      font-weight: 950;
      font-size: 14px;
    }

    .msg.ok { color: var(--ok); }
    .msg.bad { color: var(--bad); }

    .detail {
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 650;
      line-height: 1.4;
    }

    .btnRow {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .primary {
      border-color: rgba(37,99,235,0.35);
      background: rgba(37,99,235,0.06);
      color: #0b2a7a;
    }

    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: #f3f4f6;
      border: 1px solid var(--border);
      border-bottom-color: #d1d5db;
      padding: 1px 6px;
      border-radius: 6px;
      color: #374151;
      font-size: 11px;
      font-weight: 800;
    }
    footer {
        margin-top: auto;
        padding: 1rem 0;
        text-align: center;
        font-size: 0.9rem;
        color: #888;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>0x00A0ÁöÑÈü≥Á®ãÁªÉ‰π†</h1>
        <p class="sub">ÈîÆÁõòÔºö<span class="kbd">1~9</span> ÈÄâÈ°πÔºå<span class="kbd">N</span> ‰∏ã‰∏ÄÈ¢òÔºå<span class="kbd">S</span> Á≠îÊ°àÔºå<span class="kbd">R</span> ÈáçÁΩÆÁªüËÆ°„ÄÇ</p>
        <p class="sub" style="margin-top:8px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <label style="display:flex; gap:8px; align-items:center; font-weight:750; color: var(--muted);">
            <input id="optAltered" type="checkbox" />
            È¢òÁõÆ‰∏≠ÂåÖÂê´ÂèòÂåñÈü≥Á®ã
          </label>
          </p>
      </div>
      <div class="stats" aria-label="ÁªüËÆ°">
        <span>Ê≠£Á°Æ <span id="statCorrect">0</span></span>
        <span class="dot" aria-hidden="true"></span>
        <span>ÊÄªÈ¢ò <span id="statTotal">0</span></span>
        <span class="dot" aria-hidden="true"></span>
        <span>Ê≠£Á°ÆÁéá <span id="statAcc">0%</span></span>
      </div>
    </header>

    <section class="card">
      <div class="row">
        <div class="noteNames" id="noteNames">‚Äî</div>
        <div class="hint" id="dirHint">‚Äî</div>
      </div>

      <div class="staffWrap" aria-label="‰∫îÁ∫øË∞±">
        <svg id="staffSvg" viewBox="0 0 820 240" role="img" aria-label="Staff"></svg>
      </div>

      <div class="choices" id="choices"></div>

      <div class="feedback" aria-live="polite">
        <div id="msg" class="msg">ËØ∑ÈÄâÊã©Èü≥Á®ã</div>
        <div id="detail" class="detail"></div>
        <div class="btnRow">
          <button id="btnNext" class="primary" type="button">‰∏ã‰∏ÄÈ¢ò</button>
          <button id="btnShow" type="button">ÊòæÁ§∫Á≠îÊ°à</button>
          <button id="btnReset" type="button">ÈáçÁΩÆÁªüËÆ°</button>
        </div>
      </div>
    </section>
  </div>
  <footer>
      ¬© 2025 0x00A0. All rights reserved.
  </footer>

  <script>
    // =====================
    // Interval trainer (single-file, no deps)
    // =====================

    // Notes: C D E F G A B
    const LETTERS = ["C", "D", "E", "F", "G", "A", "B"]; // 0..6
    const NATURAL_PC = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };

    // Interval quality CN
    const Q_CN = { P: "Á∫Ø", M: "Â§ß", m: "Â∞è", A: "Â¢û", d: "Âáè" };
    const NUM_CN = ["", "‰∏Ä", "‰∫å", "‰∏â", "Âõõ", "‰∫î", "ÂÖ≠", "‰∏É", "ÂÖ´"]; // 1..8

    // Sort order: smaller -> larger: d < m < M < P < A
    const QUALITY_ORDER = { d: 0, m: 1, M: 2, P: 3, A: 4 };

    // Major/Perfect base semitone counts for interval numbers 1..8
    const BASE_SEMITONES = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11, 8: 12 };

    function isAlteredAllowed() {
      const el = document.getElementById("optAltered");
      return !!(el && el.checked);
    }

    function randInt(min, maxInclusive) {
      return min + Math.floor(Math.random() * (maxInclusive - min + 1));
    }

    function choice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function diatonicIndex(letter, octave) {
      return octave * 7 + LETTERS.indexOf(letter);
    }

    function semitoneOf(note) {
      return (note.octave * 12) + (NATURAL_PC[note.letter] ?? 0) + (note.accidental ?? 0);
    }

    function accidentalToText(acc) {
      if (!acc) return "";
      if (acc === 1) return "‚ôØ";
      if (acc === -1) return "‚ô≠";
      if (acc === 2) return "ùÑ™";
      if (acc === -2) return "ùÑ´";
      return acc > 0 ? "#".repeat(acc) : "b".repeat(-acc);
    }

    function noteToName(note) {
      return `${note.letter}${accidentalToText(note.accidental)}${note.octave}`;
    }

    function ensureLowHigh(a, b) {
      const sa = semitoneOf(a);
      const sb = semitoneOf(b);
      if (sa < sb) return { low: a, high: b };
      if (sb < sa) return { low: b, high: a };
      return { low: a, high: b };
    }

    function intervalNumberDiatonic(low, high) {
      return (diatonicIndex(high.letter, high.octave) - diatonicIndex(low.letter, low.octave)) + 1;
    }

    function isPerfectClass(n) {
      return n === 1 || n === 4 || n === 5 || n === 8;
    }

    function qualityFor(number, semis) {
      const base = BASE_SEMITONES[number];
      const diff = semis - base;

      if (isPerfectClass(number)) {
        if (diff === 0) return "P";
        if (diff === 1) return "A";
        if (diff === -1) return "d";
        // collapse extreme values into A/d
        return diff > 0 ? "A" : "d";
      }

      if (diff === 0) return "M";
      if (diff === -1) return "m";
      if (diff === 1) return "A";
      if (diff === -2) return "d";
      return diff > 0 ? "A" : "d";
    }

    function intervalId(iv) {
      return `${iv.quality}${iv.number}`;
    }

    function intervalText(iv) {
      const q = Q_CN[iv.quality] ?? iv.quality;
      const n = NUM_CN[iv.number] ?? String(iv.number);
      return `${q}${n}Â∫¶`;
    }

    function compareIntervals(a, b) {
      if (a.number !== b.number) return a.number - b.number;
      return (QUALITY_ORDER[a.quality] ?? 99) - (QUALITY_ORDER[b.quality] ?? 99);
    }

    // =====================
    // Generation rules (fixed defaults)
    // =====================
    const RANGE_LOW = { letter: "C", accidental: 0, octave: 4 };
    const RANGE_HIGH = { letter: "C", accidental: 0, octave: 5 };
    const ALLOWED_INTERVAL_NUMBERS = [1,2,3,4,5,6,7,8];

    function getAllowedAccidentals() {
      return isAlteredAllowed() ? [-1, 0, 1] : [0];
    }

    function generateQuestion() {
      const lowD = diatonicIndex(RANGE_LOW.letter, RANGE_LOW.octave);
      const highD = diatonicIndex(RANGE_HIGH.letter, RANGE_HIGH.octave);
      const allowedAccidentals = getAllowedAccidentals();

      for (let tries = 0; tries < 400; tries++) {
        const num = choice(ALLOWED_INTERVAL_NUMBERS);

        const maxLow = highD - (num - 1);
        if (maxLow < lowD) continue;

        const baseLowDiat = randInt(lowD, maxLow);
        const baseHighDiat = baseLowDiat + (num - 1);

        const lowOct = Math.floor(baseLowDiat / 7);
        const lowLetter = LETTERS[baseLowDiat % 7];
        const highOct = Math.floor(baseHighDiat / 7);
        const highLetter = LETTERS[baseHighDiat % 7];

        const low = { letter: lowLetter, octave: lowOct, accidental: choice(allowedAccidentals) };
        const high = { letter: highLetter, octave: highOct, accidental: choice(allowedAccidentals) };

        // Ensure within one octave in semitones (<= 12)
        const ordered = ensureLowHigh(low, high);
        const semisAsc = semitoneOf(ordered.high) - semitoneOf(ordered.low);
        if (semisAsc < 0 || semisAsc > 12) continue;

        const direction = Math.random() < 0.5 ? "up" : "down";
        const left = direction === "up" ? ordered.low : ordered.high;
        const right = direction === "up" ? ordered.high : ordered.low;

        const absSemis = Math.abs(semitoneOf(right) - semitoneOf(left));
        if (absSemis > 12) continue;

        const number = intervalNumberDiatonic(ensureLowHigh(left, right).low, ensureLowHigh(left, right).high);
        if (number < 1 || number > 8) continue;

        const quality = qualityFor(number, absSemis);


        return {
          left,
          right,
          direction,
          answer: { number, quality },
        };
      }

      return {
        left: { letter: "C", accidental: 0, octave: 5 },
        right: { letter: "C", accidental: 0, octave: 4 },
        direction: "down",
        answer: { number: 8, quality: "P" },
      };
    }

    // =====================
    // Staff renderer (treble)
    // =====================

    const STAFF = {
      width: 820,
      height: 240,
      leftPad: 80,
      rightPad: 40,
      top: 40,
      lineGap: 16,
      noteX1: 350,
      noteX2: 520,
      noteRadiusX: 14,
      noteRadiusY: 10,
      stepPx: 8,
      anchor: { letter: "E", octave: 4 }, // bottom line
    };

    function staffStepFor(note) {
      return diatonicIndex(note.letter, note.octave) - diatonicIndex(STAFF.anchor.letter, STAFF.anchor.octave);
    }

    function yForStep(step) {
      const bottomLineY = STAFF.top + 4 * STAFF.lineGap;
      return bottomLineY - step * STAFF.stepPx;
    }

    function svgEl(tag, attrs = {}) {
      const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
      for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, String(v));
      return el;
    }

    function renderStaff(svg, q) {
      svg.innerHTML = "";
      svg.setAttribute("viewBox", `0 0 ${STAFF.width} ${STAFF.height}`);

      // staff lines
      const lines = svgEl("g", { fill: "none", stroke: "var(--staff)", "stroke-width": 2 });
      for (let i = 0; i < 5; i++) {
        const y = STAFF.top + i * STAFF.lineGap;
        lines.appendChild(svgEl("line", { x1: STAFF.leftPad, x2: STAFF.width - STAFF.rightPad, y1: y, y2: y }));
      }
      svg.appendChild(lines);

      // treble clef glyph - must wrap around 2nd line (G4 line)
      const clef = svgEl("text", {
        x: STAFF.leftPad - 46,
        y: STAFF.top + 3 * STAFF.lineGap + 8,  // 2nd line from bottom (index 3 from top)
        fill: "rgba(17,24,39,0.8)",
        "font-size": 64,
        "font-family": "serif",
      });
      clef.textContent = "ùÑû";
      svg.appendChild(clef);

      const left = q.left;
      const right = q.right;

      const s1 = staffStepFor(left);
      const s2 = staffStepFor(right);
      const y1 = yForStep(s1);
      const y2 = yForStep(s2);

      const x1 = STAFF.noteX1;
      const x2 = (s1 === s2) ? (STAFF.noteX2 + 18) : STAFF.noteX2;

      // ledger lines
      const ledger = svgEl("g", { stroke: "var(--staff)", "stroke-width": 2 });
      function addLedger(step, x) {
        const minLine = 0;
        const maxLine = 8;
        if (step < minLine) {
          for (let s = -2; s >= step; s -= 2) {
            const y = yForStep(s);
            ledger.appendChild(svgEl("line", { x1: x - 26, x2: x + 26, y1: y, y2: y }));
          }
        }
        if (step > maxLine) {
          for (let s = 10; s <= step; s += 2) {
            const y = yForStep(s);
            ledger.appendChild(svgEl("line", { x1: x - 26, x2: x + 26, y1: y, y2: y }));
          }
        }
      }
      addLedger(s1, x1);
      addLedger(s2, x2);
      svg.appendChild(ledger);

      function addAccidental(note, x, y) {
        if (!note.accidental) return;
        const t = svgEl("text", {
          x: x - 34,
          y: y + 6,
          fill: "rgba(17,24,39,0.9)",
          "font-size": 28,
          "font-family": "serif",
          "text-anchor": "middle",
        });
        t.textContent = accidentalToText(note.accidental);
        svg.appendChild(t);
      }

      addAccidental(left, x1, y1);
      addAccidental(right, x2, y2);

      function addNoteHead(x, y, fill, stroke) {
        svg.appendChild(svgEl("ellipse", {
          cx: x,
          cy: y,
          rx: STAFF.noteRadiusX,
          ry: STAFF.noteRadiusY,
          fill,
          stroke,
          "stroke-width": 2,
        }));
      }

      addNoteHead(x1, y1, "rgba(37,99,235,0.16)", "rgba(37,99,235,0.85)");
      addNoteHead(x2, y2, "rgba(17,24,39,0.08)", "rgba(17,24,39,0.75)");

      function addStem(x, y, up) {
        const len = 54;
        const xs = up ? (x + STAFF.noteRadiusX - 2) : (x - STAFF.noteRadiusX + 2);
        const y2 = up ? (y - len) : (y + len);
        svg.appendChild(svgEl("line", {
          x1: xs,
          y1: y,
          x2: xs,
          y2: y2,
          stroke: "rgba(17,24,39,0.65)",
          "stroke-width": 2,
        }));
      }

      const middleY = STAFF.top + 2 * STAFF.lineGap;
      addStem(x1, y1, y1 > middleY);
      addStem(x2, y2, y2 > middleY);

      // separator
      svg.appendChild(svgEl("line", {
        x1: (STAFF.noteX1 + STAFF.noteX2) / 2,
        x2: (STAFF.noteX1 + STAFF.noteX2) / 2,
        y1: STAFF.top - 6,
        y2: STAFF.top + 4 * STAFF.lineGap + 6,
        stroke: "rgba(17,24,39,0.12)",
        "stroke-width": 3,
      }));
    }

    // =====================
    // UI + state
    // =====================

    const state = {
      current: null,
      choices: [],
      locked: false,
      total: 0,
      correct: 0,
    };

    function updateStats() {
      const total = state.total;
      const correct = state.correct;
      const acc = total ? Math.round((correct / total) * 100) : 0;
      document.getElementById("statTotal").textContent = String(total);
      document.getElementById("statCorrect").textContent = String(correct);
      document.getElementById("statAcc").textContent = `${acc}%`;
    }

    function setFeedback(kind, text, detail) {
      const msg = document.getElementById("msg");
      const det = document.getElementById("detail");

      msg.classList.remove("ok", "bad");
      if (kind === "ok") msg.classList.add("ok");
      if (kind === "bad") msg.classList.add("bad");

      msg.textContent = text;
      det.textContent = detail || "";
    }

    function setChoicesEnabled(enabled) {
      document.querySelectorAll("#choices button").forEach((b) => {
        b.disabled = !enabled;
      });
    }

    function buildChoiceSet(correct) {
      const pool = new Map();
      pool.set(intervalId(correct), correct);

      const n = correct.number;
      const candidates = [];

      // Intervals that exist in natural scale (C D E F G A B):
      // P: 1,4,5,8  M: 2,3,6,7  m: 2,3,6,7  A: only 4  d: only 5
      // When accidentals are enabled, all qualities are possible.

      const altered = isAlteredAllowed();

      // Same number: only naturally-occurring qualities (unless accidentals enabled)
      if (isPerfectClass(n)) {
        candidates.push({ number: n, quality: "P" });
        if (altered) {
          candidates.push({ number: n, quality: "d" }, { number: n, quality: "A" });
        } else {
          // Only aug4 and dim5 exist naturally
          if (n === 4) candidates.push({ number: 4, quality: "A" });
          if (n === 5) candidates.push({ number: 5, quality: "d" });
        }
      } else {
        candidates.push({ number: n, quality: "m" }, { number: n, quality: "M" });
        if (altered) {
          candidates.push({ number: n, quality: "d" }, { number: n, quality: "A" });
        }
        // For natural notes: only M/m exist for 2,3,6,7; no aug/dim
      }

      // Neighbors
      if (n > 1) candidates.push({ number: n - 1, quality: isPerfectClass(n - 1) ? "P" : "M" });
      if (n < 8) candidates.push({ number: n + 1, quality: isPerfectClass(n + 1) ? "P" : "M" });

      for (const c of candidates) {
        const id = intervalId(c);
        if (!pool.has(id)) pool.set(id, c);
      }

      // Fill to 9 with naturally-occurring intervals
      const NATURAL_COMMON = [
        { number: 1, quality: "P" },
        { number: 2, quality: "m" },
        { number: 2, quality: "M" },
        { number: 3, quality: "m" },
        { number: 3, quality: "M" },
        { number: 4, quality: "P" },
        { number: 4, quality: "A" },  // F-B
        { number: 5, quality: "d" },  // B-F
        { number: 5, quality: "P" },
        { number: 6, quality: "m" },
        { number: 6, quality: "M" },
        { number: 7, quality: "m" },
        { number: 7, quality: "M" },
        { number: 8, quality: "P" },
      ];

      // If accidentals enabled, add more exotic intervals
      const ALTERED_COMMON = [
        { number: 2, quality: "A" },
        { number: 2, quality: "d" },
        { number: 3, quality: "A" },
        { number: 3, quality: "d" },
        { number: 6, quality: "A" },
        { number: 6, quality: "d" },
        { number: 7, quality: "A" },
        { number: 7, quality: "d" },
      ];

      const commonPool = altered ? [...NATURAL_COMMON, ...ALTERED_COMMON] : NATURAL_COMMON;

      for (const c of commonPool) {
        if (pool.size >= 9) break;
        const id = intervalId(c);
        if (!pool.has(id)) pool.set(id, c);
      }

      const arr = Array.from(pool.values());
      while (arr.length > 9) arr.splice(randInt(0, arr.length - 1), 1);

      // Required: sort from small to large
      arr.sort(compareIntervals);
      return arr;
    }

    function renderChoices(choices) {
      const wrap = document.getElementById("choices");
      wrap.innerHTML = "";

      for (let i = 0; i < choices.length; i++) {
        const c = choices[i];
        const btn = document.createElement("button");
        btn.type = "button";
        btn.dataset.id = intervalId(c);
        btn.textContent = `${i + 1}. ${intervalText(c)}`;
        btn.addEventListener("click", () => answer(c));
        wrap.appendChild(btn);
      }
    }

    function renderQuestion() {
      state.current = generateQuestion();
      state.locked = false;

      const leftName = noteToName(state.current.left);
      const rightName = noteToName(state.current.right);
      document.getElementById("noteNames").textContent = `${leftName} ‚Üí ${rightName}`;
      document.getElementById("dirHint").textContent = state.current.direction === "up" ? "‰∏äË°å" : "‰∏ãË°å";

      renderStaff(document.getElementById("staffSvg"), state.current);

      state.choices = buildChoiceSet(state.current.answer);
      renderChoices(state.choices);
      setChoicesEnabled(true);

      setFeedback("", "ËØ∑ÈÄâÊã©Èü≥Á®ã", "");
    }

    function answer(selected) {
      if (!state.current || state.locked) return;

      const correct = state.current.answer;
      const ok = intervalId(selected) === intervalId(correct);

      state.total += 1;

      const leftName = noteToName(state.current.left);
      const rightName = noteToName(state.current.right);

      if (ok) {
        state.correct += 1;
        state.locked = true;
        setChoicesEnabled(false);
        setFeedback("ok", "Ê≠£Á°Æ", `${leftName} ‚Üí ${rightName} = ${intervalText(correct)}`);
        updateStats();
        window.setTimeout(() => renderQuestion(), 650);
      } else {
        setFeedback("bad", "‰∏çÂØπ", `‰Ω†ÈÄâ‰∫Ü ${intervalText(selected)}ÔºõÊ≠£Á°ÆÊòØ ${intervalText(correct)}Ôºà${leftName} ‚Üí ${rightName}Ôºâ`);
        updateStats();
      }
    }

    function showAnswer() {
      if (!state.current) return;
      const leftName = noteToName(state.current.left);
      const rightName = noteToName(state.current.right);
      setFeedback("", "Á≠îÊ°à", `${leftName} ‚Üí ${rightName} = ${intervalText(state.current.answer)}`);
    }

    function resetStats() {
      state.total = 0;
      state.correct = 0;
      updateStats();
      renderQuestion();
    }

    function wireEvents() {
      document.getElementById("btnNext").addEventListener("click", () => renderQuestion());
      document.getElementById("btnShow").addEventListener("click", () => showAnswer());
      document.getElementById("btnReset").addEventListener("click", () => resetStats());

      const opt = document.getElementById("optAltered");
      if (opt) {
        opt.addEventListener("change", () => {
          // New setting takes effect immediately.
          renderQuestion();
        });
      }

      window.addEventListener("keydown", (e) => {
        const k = e.key;
        if (k >= "1" && k <= "9") {
          const idx = parseInt(k, 10) - 1;
          const c = state.choices[idx];
          if (c) answer(c);
        }
        if (k === "n" || k === "N") renderQuestion();
        if (k === "s" || k === "S") showAnswer();
        if (k === "r" || k === "R") resetStats();
      });
    }

    // boot
    wireEvents();
    updateStats();
    renderQuestion();
  </script>
</body>
</html>
